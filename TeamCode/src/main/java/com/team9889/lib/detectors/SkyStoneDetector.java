package com.team9889.lib.detectors;

import com.disnodeteam.dogecv.detectors.DogeCVDetector;

import org.opencv.core.Core;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.core.Size;
import org.opencv.imgproc.Imgproc;

/**
 * SkyStoneDetector class.
 *
 * <p>An OpenCV pipeline generated by GRIP.
 *
 * @author GRIP
 */

public class SkyStoneDetector extends DogeCVDetector {

    //Outputs
    private Mat cvResizeOutput = new Mat();
    private Mat hslThresholdOutput = new Mat();
    private Mat cvErodeOutput = new Mat();
    private Mat maskOutput = new Mat();
    private Number findMinAndMaxMinVal;
    private Number findMinAndMaxMaxVal;
    private Point findMinAndMaxMinLoc = new Point();
    private Point findMinAndMaxMaxLoc = new Point();

    private double xPosition;

    static {
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
    }

    /**
     * This is the primary method that runs the entire pipeline and updates the outputs.
     * @return
     */
    public Mat process(Mat source0) {
        // Step CV_resize0:
        Mat cvResizeSrc = source0;
        Size cvResizeDsize = new Size(0, 0);
        double cvResizeFx = 0.25;
        double cvResizeFy = 0.25;
        int cvResizeInterpolation = Imgproc.INTER_LINEAR;
        cvResize(cvResizeSrc, cvResizeDsize, cvResizeFx, cvResizeFy, cvResizeInterpolation, cvResizeOutput);

        // Step HSL_Threshold0:
        Mat hslThresholdInput = cvResizeOutput;
        double[] hslThresholdHue = {124.43299597610047, 146.31016042780746};
        double[] hslThresholdSaturation = {0.0, 254.0828908312376};
        double[] hslThresholdLuminance = {0.0, 53.27800186161961};
        hslThreshold(hslThresholdInput, hslThresholdHue, hslThresholdSaturation, hslThresholdLuminance, hslThresholdOutput);

        // Step CV_erode0:
        Mat cvErodeSrc = hslThresholdOutput;
        Mat cvErodeKernel = new Mat();
        Point cvErodeAnchor = new Point(-1, -1);
        double cvErodeIterations = 1.0;
        int cvErodeBordertype = Core.BORDER_CONSTANT;
        Scalar cvErodeBordervalue = new Scalar(-1);
        cvErode(cvErodeSrc, cvErodeKernel, cvErodeAnchor, cvErodeIterations, cvErodeBordertype, cvErodeBordervalue, cvErodeOutput);

        // Step Mask0:
        Mat maskInput = hslThresholdOutput;
        Mat maskMask = cvErodeOutput;
        mask(maskInput, maskMask, maskOutput);

        // Step Find_Min_and_Max0:
        Mat findMinAndMaxImage = maskOutput;
        Mat findMinAndMaxMask = cvErodeOutput;
        Ref<Number> findMinAndMaxMinValRef = new Ref<Number>();
        Ref<Number> findMinAndMaxMaxValRef = new Ref<Number>();
        findMinAndMax(findMinAndMaxImage, findMinAndMaxMask, findMinAndMaxMinValRef, findMinAndMaxMaxValRef, findMinAndMaxMinLoc, findMinAndMaxMaxLoc);
        findMinAndMaxMinVal = findMinAndMaxMinValRef.get();
        findMinAndMaxMaxVal = findMinAndMaxMaxValRef.get();

        xPosition = findMinAndMaxMaxVal.doubleValue();
        return cvResizeSrc;
    }

    @Override
    public void useDefaults() {

    }

    /**
     * This method is a generated getter for the output of a CV_resize.
     * @return Mat output from CV_resize.
     */
    public Mat cvResizeOutput() {
        return cvResizeOutput;
    }

    /**
     * This method is a generated getter for the output of a HSL_Threshold.
     * @return Mat output from HSL_Threshold.
     */
    public Mat hslThresholdOutput() {
        return hslThresholdOutput;
    }

    /**
     * This method is a generated getter for the output of a CV_erode.
     * @return Mat output from CV_erode.
     */
    public Mat cvErodeOutput() {
        return cvErodeOutput;
    }

    /**
     * This method is a generated getter for the output of a Mask.
     * @return Mat output from Mask.
     */
    public Mat maskOutput() {
        return maskOutput;
    }

    /**
     * This method is a generated getter for the output of a Find_Min_and_Max.
     * @return Number output from Find_Min_and_Max.
     */
    public Number findMinAndMaxMinVal() {
        return findMinAndMaxMinVal;
    }

    /**
     * This method is a generated getter for the output of a Find_Min_and_Max.
     * @return Number output from Find_Min_and_Max.
     */
    public Number findMinAndMaxMaxVal() {
        return findMinAndMaxMaxVal;
    }

    /**
     * This method is a generated getter for the output of a Find_Min_and_Max.
     * @return Point output from Find_Min_and_Max.
     */
    public Point findMinAndMaxMinLoc() {
        return findMinAndMaxMinLoc;
    }

    /**
     * This method is a generated getter for the output of a Find_Min_and_Max.
     * @return Point output from Find_Min_and_Max.
     */
    public Point findMinAndMaxMaxLoc() {
        return findMinAndMaxMaxLoc;
    }


    /**
     * Resizes an image.
     * @param src The image to resize.
     * @param dSize size to set the image.
     * @param fx scale factor along X axis.
     * @param fy scale factor along Y axis.
     * @param interpolation type of interpolation to use.
     * @param dst output image.
     */
    private void cvResize(Mat src, Size dSize, double fx, double fy, int interpolation,
                          Mat dst) {
        if (dSize==null) {
            dSize = new Size(0,0);
        }
        Imgproc.resize(src, dst, dSize, fx, fy, interpolation);
    }

    /**
     * Segment an image based on hue, saturation, and luminance ranges.
     *
     * @param input The image on which to perform the HSL threshold.
     * @param hue The min and max hue
     * @param sat The min and max saturation
     * @param lum The min and max luminance
     * @param out The image in which to store the output.
     */
    private void hslThreshold(Mat input, double[] hue, double[] sat, double[] lum,
                              Mat out) {
        Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2HLS);
        Core.inRange(out, new Scalar(hue[0], lum[0], sat[0]),
                new Scalar(hue[1], lum[1], sat[1]), out);
    }

    /**
     * Expands area of lower value in an image.
     * @param src the Image to erode.
     * @param kernel the kernel for erosion.
     * @param anchor the center of the kernel.
     * @param iterations the number of times to perform the erosion.
     * @param borderType pixel extrapolation method.
     * @param borderValue value to be used for a constant border.
     * @param dst Output Image.
     */
    private void cvErode(Mat src, Mat kernel, Point anchor, double iterations,
                         int borderType, Scalar borderValue, Mat dst) {
        if (kernel == null) {
            kernel = new Mat();
        }
        if (anchor == null) {
            anchor = new Point(-1,-1);
        }
        if (borderValue == null) {
            borderValue = new Scalar(-1);
        }
        Imgproc.erode(src, dst, kernel, anchor, (int)iterations, borderType, borderValue);
    }

    /**
     * Filter out an area of an image using a binary mask.
     * @param input The image on which the mask filters.
     * @param mask The binary image that is used to filter.
     * @param output The image in which to store the output.
     */
    private void mask(Mat input, Mat mask, Mat output) {
        mask.convertTo(mask, CvType.CV_8UC1);
        Core.bitwise_xor(output, output, output);
        input.copyTo(output, mask);
    }

    /**
     * Finds the minimum and maximum values of the Mat as well as the associated points.
     * @param src the Mat to find min and max for.
     * @param mask the Mat to use as a mask for the operation.
     * @param minVal the minimum value found in the Mat.
     * @param maxVal the maximum value found in the Mat.
     * @param minLoc the location of the minimum value.
     * @param maxLoc the location of the maximum value.
     */
    private void findMinAndMax(Mat src, Mat mask, Ref<Number> minVal,
                               Ref<Number> maxVal, Point minLoc, Point maxLoc) {
        Core.MinMaxLocResult data = Core.minMaxLoc(src);
        minVal.set(Double.valueOf(data.minVal));
        maxVal.set(Double.valueOf(data.maxVal));
        minLoc.x = data.minLoc.x;
        minLoc.y = data.minLoc.y;
        maxLoc.x = data.maxLoc.x;
        maxLoc.y = data.maxLoc.y;
    }


    /**
     * Enables C-style output parameters in Java to avoid creating custom data classes for each
     * operation.
     *
     * <p>Syntax is {@code Ref<T> varName = new Ref<T>(initValue)}.
     * Where varName is the name of the variable and initValue is of type T and contains initial value.
     * </p>
     * @param <T> The type of object being referenced
     */
    private static class Ref<T> {
        private T value;

        /**
         * Constructor for a Ref object.
         * @param initValue Type T initial value for the object.
         */
        public Ref(T initValue) {
            value = initValue;
        }

        /**
         * Constructor for a Ref object without an initial value.
         * Equivalent to calling Ref(null)
         */
        public Ref() {
            this(null);
        }

        /**
         * Sets the object to contain a new value.
         *
         * @param newValue the new value being referenced
         */
        public void set(T newValue) {
            value = newValue;
        }

        /**
         * Gets the current referenced value
         *
         * @return the current referenced value
         */
        public T get() {
            return value;
        }

    }

    public double getXPosition(){
        return xPosition;
    }
}